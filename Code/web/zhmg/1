// image_chat.js

// 获取DOM元素
const imageUploadBtn = document.getElementById('imageUploadBtn');
const imageInput = document.getElementById('imageInput');

// 使用全局的 messages
const messages = window.messages;

// 检查必要的元素是否存在
if (!imageUploadBtn || !imageInput || !messages) {
    console.error("图片上传相关的DOM元素未找到。请检查HTML结构。");
}

// 监听上传按钮点击，触发文件选择
imageUploadBtn.addEventListener('click', () => {
    console.log("上传图片按钮被点击");
    imageInput.click();
});

// 处理文件选择
imageInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file && (file.type === 'image/png' || file.type === 'image/jpeg')) {
        const reader = new FileReader();
        reader.onload = async function(e) {
            const base64Image = e.target.result.split(',')[1]; // 去除前缀
            // 生成消息ID和时间戳
            const messageId = 'img_' + Date.now();
            const timestamp = new Date().toLocaleTimeString();

            // 显示自己的图片消息（带有锁定的覆盖层）
            displayChatImage('您', base64Image, timestamp, true, messageId);

            // 构建图片消息数据
            const messageData = {
                type: 'image',
                id: messageId,
                content: base64Image
            };

            // 加密消息，确保使用 window.sessionKey
            const encryptedMessage = window.encryptMessage(JSON.stringify(messageData), window.sessionKey);
            if (!encryptedMessage) {
                alert('图片加密失败，请检查控制台获取更多信息。');
                return;
            }

            // 发送加密消息到服务器
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(encryptedMessage);
                console.log('已发送加密图片消息到服务器:', encryptedMessage);
            } else {
                alert('聊天服务器尚未连接，请稍后再试。');
            }

            // 清空文件输入
            imageInput.value = '';
        };
        reader.readAsDataURL(file);
    } else {
        alert('请选择一个PNG或JPEG格式的图片。');
    }
});

// 显示图片消息
function displayChatImage(username, base64Image, timestamp, isOwnMessage = false, messageId = null) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message');
    if (messageId) {
        messageElement.dataset.messageId = messageId; // 设置消息ID
    }

    const usernameElement = document.createElement('span');
    usernameElement.classList.add('msg-username');
    usernameElement.textContent = username;

    const timeElement = document.createElement('span');
    timeElement.classList.add('msg-time');
    timeElement.textContent = `(${timestamp})`;

    const imageContainer = document.createElement('div');
    imageContainer.classList.add('image-container');

    const imgElement = document.createElement('img');
    imgElement.src = `data:image/png;base64,${base64Image}`;
    imgElement.classList.add('chat-image');
    imgElement.style.display = 'none'; // 初始隐藏

    const lockOverlay = document.createElement('div');
    lockOverlay.classList.add('lock-overlay');
    lockOverlay.textContent = '点击解锁图片';

    // 点击解锁图片
    lockOverlay.addEventListener('click', () => {
        imgElement.style.display = 'block';
        lockOverlay.style.display = 'none';
    });

    imageContainer.appendChild(imgElement);
    imageContainer.appendChild(lockOverlay);

    messageElement.appendChild(usernameElement);
    messageElement.appendChild(timeElement);
    messageElement.appendChild(imageContainer);

    // 如果是自己发送的图片，添加撤回和编辑按钮
    if (isOwnMessage && messageId) {
        // 撤回按钮
        const revokeButton = document.createElement('button');
        revokeButton.textContent = '撤回';
        revokeButton.classList.add('revoke-btn', 'unified-btn');
        revokeButton.style.marginLeft = '10px';
        revokeButton.addEventListener('click', function () {
            if (confirm('确定要撤回此图片吗？')) {
                revokeMessage(messageId);
            }
        });

        // 编辑按钮（例如替换图片）
        const editButton = document.createElement('button');
        editButton.textContent = '编辑';
        editButton.classList.add('edit-btn', 'unified-btn');
        editButton.style.marginLeft = '10px';
        editButton.addEventListener('click', function () {
            imageInput.click(); // 重新选择图片
            // 监听文件选择并替换图片
            imageInput.onchange = async function(e) {
                const newFile = e.target.files[0];
                if (newFile && (newFile.type === 'image/png' || newFile.type === 'image/jpeg')) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const newBase64Image = event.target.result.split(',')[1];
                        // 更新图片显示
                        imgElement.src = `data:image/png;base64,${newBase64Image}`;
                        imgElement.style.display = 'none';
                        lockOverlay.style.display = 'block';

                        // 构建编辑消息数据
                        const editData = {
                            type: 'edit_image',
                            id: messageId,
                            newContent: newBase64Image
                        };

                        // 加密消息
                        const encryptedEdit = window.encryptMessage(JSON.stringify(editData), window.sessionKey);
                        if (!encryptedEdit) {
                            alert('图片编辑加密失败，请检查控制台获取更多信息。');
                            return;
                        }

                        // 发送加密编辑消息到服务器
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(encryptedEdit);
                            console.log('已发送加密编辑图片消息到服务器:', encryptedEdit);
                        } else {
                            alert('聊天服务器尚未连接，请稍后再试。');
                        }

                        // 清空文件输入
                        imageInput.value = '';
                    };
                    reader.readAsDataURL(newFile);
                } else {
                    alert('请选择一个PNG或JPEG格式的图片。');
                }
            };
        });

        // 将按钮添加到消息元素中
        messageElement.appendChild(editButton);
        messageElement.appendChild(revokeButton);
    }

    // 将消息元素添加到消息容器中
    messages.appendChild(messageElement);
    messages.scrollTop = messages.scrollHeight; // 滚动到最底部
}

// 处理接收的图片消息
function handleIncomingImageMessage(messageData) {
    const { id, timestamp, username, content } = messageData;
    displayChatImage(username, content, timestamp, false, id);
}

// 监听来自服务器的消息
document.addEventListener('messageReceived', function (event) {
    const messageData = event.detail;
    if (messageData.type === 'image') {
        handleIncomingImageMessage(messageData);
    } else if (messageData.type === 'edit_image') {
        // 处理编辑后的图片
        const { id, newContent } = messageData;
        const messageElements = document.querySelectorAll(`[data-message-id="${id}"]`);
        messageElements.forEach(elem => {
            const imgElement = elem.querySelector('.chat-image');
            const lockOverlay = elem.querySelector('.lock-overlay');
            if (imgElement && lockOverlay) {
                imgElement.src = `data:image/png;base64,${newContent}`;
                imgElement.style.display = 'none';
                lockOverlay.style.display = 'block';
                console.log(`已更新消息ID: ${id} 的图片内容`);
            }
        });
    }
});
// chat.js

// 获取DOM元素
window.messages = document.getElementById('messages');
const chatForm = document.getElementById('chatForm');
const chatInput = document.getElementById('chatInput');
const getKeyBtn = document.getElementById('getKeyBtn');
const keyDisplay = document.getElementById('keyDisplay');
const userKeySpan = document.getElementById('userKey');
const onlineUsersDiv = document.getElementById('onlineUsers');

// 检查DOM元素是否存在
if (!window.messages || !chatForm || !chatInput || !getKeyBtn || !keyDisplay || !userKeySpan || !onlineUsersDiv) {
    console.error("One or more DOM elements were not found. Please check the HTML structure.");
}

// 将 PRE_SHARED_KEY 附加到 window 对象，使其在全局范围内可访问
window.PRE_SHARED_KEY = 'G6JrXcZLw1Q8P3F7d9K0M2N4B6V8Y1A3'; // 替换为您的32字符密钥

// 将 sessionKey 附加到 window 对象，使其在全局范围内可访问
window.sessionKey = null; // WordArray
let ws = null;
let reconnectInterval = 5000; // 5秒后重连

let ownIP = null; // 存储自己的IP

// 验证预共享密钥长度
console.log(`Client PRE_SHARED_KEY length: ${window.PRE_SHARED_KEY.length} characters`); // 应为32

if (window.PRE_SHARED_KEY.length !== 32) {
    console.error("预共享密钥长度不正确。应为32字符。");
    alert("预共享密钥长度不正确。请联系管理员。");
}

// 加密函数
window.encryptMessage = // 加密时将IV放在密文的前面，然后一起Base64编码发送
function encryptMessage(message, keyWordArray) {
    const iv = CryptoJS.lib.WordArray.random(16);
    const encrypted = CryptoJS.AES.encrypt(message, keyWordArray, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    const ivCiphertext = iv.concat(encrypted.ciphertext);
    return CryptoJS.enc.Base64.stringify(ivCiphertext);
}


// 解密函数
window.decryptMessage = function decryptMessage(encryptedMessage, keyWordArray) {
    try {
        const ivCiphertext = CryptoJS.enc.Base64.parse(encryptedMessage);
        const iv = CryptoJS.lib.WordArray.create(ivCiphertext.words.slice(0, 4)); // 16 bytes = 4 words
        const ciphertext = CryptoJS.lib.WordArray.create(ivCiphertext.words.slice(4));

        console.log(`解密中的 IV: ${CryptoJS.enc.Hex.stringify(iv)}`);  // 打印 IV
        console.log(`解密中的密文: ${CryptoJS.enc.Hex.stringify(ciphertext)}`); // 打印密文

        const decrypted = CryptoJS.AES.decrypt({ ciphertext: ciphertext }, keyWordArray, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
        const plaintext = decrypted.toString(CryptoJS.enc.Utf8);
        return plaintext;
    } catch (error) {
        console.error('解密消息失败:', error);
        return null;
    }
}

// 显示聊天消息
function displayChatMessage(username, text, timestamp, isOwnMessage = false, messageId = null) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message');
    if (messageId) {
        messageElement.dataset.messageId = messageId; // 设置消息ID
    }

    const usernameElement = document.createElement('span');
    usernameElement.classList.add('msg-username');
    usernameElement.textContent = username;

    const timeElement = document.createElement('span');
    timeElement.classList.add('msg-time');
    timeElement.textContent = `(${timestamp})`;

    const textElement = document.createElement('span');
    textElement.classList.add('msg-text');
    textElement.textContent = text;

    messageElement.appendChild(usernameElement);
    messageElement.appendChild(timeElement);
    messageElement.appendChild(textElement);

    // 如果是自己发送的消息，添加撤回和编辑按钮
    if (isOwnMessage && messageId) {
        // 撤回按钮
        const revokeButton = document.createElement('button');
        revokeButton.textContent = '撤回';
        revokeButton.classList.add('revoke-btn', 'unified-btn');
        revokeButton.style.marginLeft = '10px';
        revokeButton.addEventListener('click', function () {
            if (confirm('确定要撤回此消息吗？')) {
                revokeMessage(messageId);
            }
        });

        // 编辑按钮
        const editButton = document.createElement('button');
        editButton.textContent = '编辑';
        editButton.classList.add('edit-btn', 'unified-btn');
        editButton.style.marginLeft = '10px';
        editButton.addEventListener('click', function () {
            const newContent = prompt('编辑您的消息：', text);
            if (newContent !== null && newContent.trim() !== '') {
                editMessage(messageId, newContent.trim());
            }
        });

        // 将按钮添加到消息元素中
        messageElement.appendChild(editButton);
        messageElement.appendChild(revokeButton);
    }

    // 将消息元素添加到消息容器中
    window.messages.appendChild(messageElement);
    window.messages.scrollTop = window.messages.scrollHeight; // 滚动到最底部
}

// 显示系统消息
function displaySystemMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message');

    const usernameElement = document.createElement('span');
    usernameElement.classList.add('msg-username');
    usernameElement.textContent = '系统';

    const timeElement = document.createElement('span');
    timeElement.classList.add('msg-time');
    const timestamp = new Date().toLocaleTimeString();
    timeElement.textContent = `(${timestamp})`;

    const textElement = document.createElement('span');
    textElement.classList.add('msg-text');
    textElement.textContent = text;

    messageElement.appendChild(usernameElement);
    messageElement.appendChild(timeElement);
    messageElement.appendChild(textElement);

    window.messages.appendChild(messageElement);
    window.messages.scrollTop = window.messages.scrollHeight; // 滚动到最底部
}

function displayYourIP(ip, country, region, city, district, isp) {
    onlineUsersDiv.innerHTML = `<h3>实机IP</h3>
    <p>IP: ${ip}</p>
    <p>国家: ${country}</p>
    <p>省份: ${region}</p>
    <p>城市: ${city}</p>
    <p>区: ${district}</p>
    <p>运营商: ${isp}</p>
    <h3>在线用户</h3>`;
    console.log('显示 IP 信息: ', { ip, country, region, city, district, isp });
}

// 更新在线用户列表
function updateOnlineUsers(users) {
    onlineUsersDiv.innerHTML = `<h3>实机IP</h3>
    <p>${ownIP}</p>
    <h3>在线用户</h3>`;

    if (users.length === 0) {
        onlineUsersDiv.innerHTML += '<p>暂无在线用户。</p>';
    } else {
        const ul = document.createElement('ul');
        for (const user of users) {
            // 跳过自己
            if (user.ip === ownIP) {
                continue;
            }

            // 跳过本地IP
            if (user.ip === '127.0.0.1' || user.ip === '::1') {
                continue;
            }

            const li = document.createElement('li');
            li.textContent = `    ${user.ip}`;
            ul.appendChild(li);
        }
        if (ul.children.length === 0) {
            onlineUsersDiv.innerHTML += '<p>暂无在线用户。</p>';
        } else {
            onlineUsersDiv.appendChild(ul);
        }
    }
}

// 连接到 WebSocket 服务器
function connectWebSocket() {
    if (!window.sessionKey) {
        console.log('等待接收会话密钥...');
    }

    // 如果已经存在连接，先关闭
    if (ws) {
        ws.close();
    }

    // 请将下面的URL替换为您的服务器地址和端口
    const serverIP = 'dwgx.e2.luyouxia.net'; // 替换为您的服务器IP
    const serverPort = '20008'; // 替换为您的服务器端口，例如20008
    const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${wsProtocol}://${serverIP}:${serverPort}`;

    console.log(`尝试连接 WebSocket 服务器: ${wsUrl}`);
    ws = new WebSocket(wsUrl);

    ws.onopen = function () {
        console.log('已连接到聊天服务器');
        displaySystemMessage('已连接到聊天服务器');

        // 连接后发送用户的真实 IP 地址给服务器
        const ipData = {
            type: 'client_ip',
            ip: ownIP
        };
        ws.send(JSON.stringify(ipData));
        console.log('已发送客户端 IP 地址给服务器:', ipData);

        // 连接后发送用户的密钥交换请求
        const keyExchangeRequest = {
            type: 'request_session_key'
        };
        ws.send(JSON.stringify(keyExchangeRequest));
        console.log('已发送密钥交换请求:', keyExchangeRequest);
    };

    ws.onmessage = function (event) {
        const encryptedMsg = event.data;
        console.log(`接收到的加密消息: ${encryptedMsg}`); // 调试日志

        // 首先处理会话密钥消息
        if (!window.sessionKey) {
            // 会话密钥消息类型为 'session_key'
            try {
                const messageData = JSON.parse(encryptedMsg);
                if (messageData.type === 'session_key') {
                    console.log('接收到会话密钥消息:', messageData);
                    // 使用预共享密钥解密会话密钥
                    const decryptedSessionKey = window.decryptMessage(messageData.session_key, CryptoJS.enc.Utf8.parse(window.PRE_SHARED_KEY));
                    if (decryptedSessionKey) {
                        // decryptedSessionKey 是 Base64 编码的 session_key_bytes
                        const sessionKeyWordArray = CryptoJS.enc.Base64.parse(decryptedSessionKey);
                        window.sessionKey = sessionKeyWordArray;
                        console.log(`接收到会话密钥: ${CryptoJS.enc.Base64.stringify(window.sessionKey)}`);
                        userKeySpan.textContent = decryptedSessionKey;
                        displaySystemMessage('会话密钥已接收，开始安全通信。');

                        // 触发 messageReceived 事件
                        document.dispatchEvent(new CustomEvent('messageReceived', { detail: messageData }));

                        return;
                    } else {
                        console.error('会话密钥解密失败');
                        displaySystemMessage('会话密钥解密失败。');
                        return;
                    }
                }
            } catch (error) {
                console.error('处理会话密钥消息失败:', error);
                displaySystemMessage('处理会话密钥消息失败。');
                return;
            }
        }

        if (window.sessionKey) {
            const decryptedMsg = window.decryptMessage(encryptedMsg, window.sessionKey);
            if (decryptedMsg) {
                try {
                    const messageData = JSON.parse(decryptedMsg);
                    console.log('解密后的消息数据:', messageData);

                    if (messageData.type === 'message') {
                        const { id, timestamp, username, content } = messageData;
                        displayChatMessage(username, content, timestamp, false, id);
                    } else if (messageData.type === 'revoke') {
                        const { id } = messageData;
                        // 删除对应的消息
                        const messageElements = document.querySelectorAll(`[data-message-id="${id}"]`);
                        messageElements.forEach(elem => elem.remove());
                    } else if (messageData.type === 'edit') {
                        const { id, newContent } = messageData;
                        // 查找对应的消息并更新内容
                        const messageElements = document.querySelectorAll(`[data-message-id="${id}"]`);
                        messageElements.forEach(elem => {
                            const textElement = elem.querySelector('.msg-text');
                            if (textElement) {
                                textElement.textContent = newContent;
                            }
                        });
                    } else if (messageData.type === 'system') {
                        displaySystemMessage(messageData.content);
                    } else if (messageData.type === 'update_online_users') {
                        const users = messageData.users;
                        updateOnlineUsers(users);
                    } else if (messageData.type === 'your_ip') {
                        const { ip, country, region, city, district, isp } = messageData;
                        ownIP = ip;
                        displayYourIP(ip, country, region, city, district, isp);
                    }

                    // 触发 messageReceived 事件
                    document.dispatchEvent(new CustomEvent('messageReceived', { detail: messageData }));

                } catch (error) {
                    console.error('消息解析失败:', error);
                }
            } else {
                console.error('解密消息失败');
            }
        }
    };

    ws.onclose = function (event) {
        console.log('已断开与聊天服务器的连接');
        displaySystemMessage('已断开与聊天服务器的连接');
        // 自动重连
        setTimeout(() => {
            displaySystemMessage('尝试重新连接聊天服务器...');
            connectWebSocket();
        }, reconnectInterval);
    };

    ws.onerror = function (error) {
        console.error('WebSocket错误:', error);
        displaySystemMessage('WebSocket连接出现错误，请稍后重试。');
    };
}

// 获取密钥的功能（在此方案中不需要生成密钥）
getKeyBtn.addEventListener('click', function () {
    alert('会话密钥将在连接时自动生成。');
});

// 显示预共享密钥
document.addEventListener('DOMContentLoaded', function () {
    keyDisplay.style.display = 'block';
    userKeySpan.textContent = '生成中...';
    displaySystemMessage('使用预共享密钥。系统正在连接聊天服务器。');
    // 连接将在获取IP后触发
});

// 处理获取 IP 失败的情况
document.addEventListener('clientIPFetchError', function (event) {
    const errorMsg = event.detail.error;
    console.error("获取客户端 IP 失败:", errorMsg);
    displaySystemMessage("获取客户端 IP 失败，无法连接聊天服务器。");
});

// 处理获取 IP 成功的情况
document.addEventListener('clientIPFetched', function (event) {
    const ipInfo = event.detail;
    console.log("获取到的 IP 信息:", ipInfo); // 调试日志
    ownIP = ipInfo.ip;
    displayYourIP(ipInfo.ip, ipInfo.country, ipInfo.region, ipInfo.city, ipInfo.district, ipInfo.isp);
    console.log("已显示 IP 信息，准备连接 WebSocket"); // 调试日志
    // 连接WebSocket
    connectWebSocket();
});

// 页面加载时的初始化逻辑
document.addEventListener('DOMContentLoaded', function () {
    // 隐藏加载动画并显示主容器
    const loadingOverlay = document.getElementById('loadingOverlay');
    const mainContainer = document.getElementById('mainContainer');
    if (loadingOverlay && mainContainer) {
        loadingOverlay.style.display = 'none';
        mainContainer.style.display = 'block';
        console.log('隐藏加载动画并显示主容器');
    } else {
        console.error('加载动画或主容器未找到');
    }

    // 平滑滚动效果
    const links = document.querySelectorAll('nav a');
    for (const link of links) {
        link.addEventListener('click', smoothScroll);
    }

    // 加入频道按钮点击事件
    const joinChannelButtons = document.querySelectorAll('.join-channel-btn');
    joinChannelButtons.forEach(button => {
        button.addEventListener('click', function () {
            window.location.href = 'https://pd.qq.com/s/9m10fpwyu';
        });
    });

    // 卡片翻转事件
    const flipButtons = document.querySelectorAll('.flip-btn');
    flipButtons.forEach(button => {
        button.addEventListener('click', function () {
            const cardInner = this.closest('.card-inner');
            cardInner.classList.toggle('is-flipped');
        });
    });

    const flipBackButtons = document.querySelectorAll('.flip-back-btn');
    flipBackButtons.forEach(button => {
        button.addEventListener('click', function () {
            const cardInner = this.closest('.card-inner');
            cardInner.classList.toggle('is-flipped');
        });
    });
});

// 绑定表单提交事件
if (chatForm) {
    chatForm.addEventListener('submit', async function (e) {
        e.preventDefault(); // 阻止默认提交行为
        console.log('提交事件已触发'); // 调试日志
        const message = chatInput.value.trim();
        if (message === '') return;

        // 生成消息ID和时间戳
        const messageId = 'msg_' + Date.now();
        const timestamp = new Date().toLocaleTimeString();

        // 显示自己的消息
        displayChatMessage('您', message, timestamp, true, messageId);

        // 构建消息数据
        const messageData = {
            type: 'message',
            id: messageId,
            content: message
        };

        // 加密消息
        const encryptedMessage = window.encryptMessage(JSON.stringify(messageData), window.sessionKey);
        if (!encryptedMessage) {
            alert('消息加密失败，请检查控制台获取更多信息。');
            return;
        }

        // 发送加密消息到服务器
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(encryptedMessage);
            console.log('已发送加密消息到服务器:', encryptedMessage);
        } else {
            alert('聊天服务器尚未连接，请稍后再试。');
        }

        // 清空输入框
        chatInput.value = '';
    });
} else {
    console.error('chatForm 元素未找到。');
}

// 撤回消息函数
async function revokeMessage(messageId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        const revokeData = {
            type: 'revoke',
            id: messageId
        };
        const revokeString = JSON.stringify(revokeData);
        const encryptedRevoke = window.encryptMessage(revokeString, window.sessionKey);
        if (!encryptedRevoke) {
            alert('消息撤回加密失败，请检查控制台获取更多信息。');
            return;
        }
        ws.send(encryptedRevoke);
        console.log('已发送撤回消息到服务器:', encryptedRevoke);
        // 本地删除消息
        const messageElements = document.querySelectorAll(`[data-message-id="${messageId}"]`);
        messageElements.forEach(elem => elem.remove());
    } else {
        alert('聊天服务器尚未连接，请稍后再试。');
    }
}

// 编辑消息函数
async function editMessage(messageId, newContent) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        const editData = {
            type: 'edit',
            id: messageId,
            newContent: newContent
        };
        const editString = JSON.stringify(editData);
        const encryptedEdit = window.encryptMessage(editString, window.sessionKey);
        if (!encryptedEdit) {
            alert('消息编辑加密失败，请检查控制台获取更多信息。');
            return;
        }
        ws.send(encryptedEdit);
        console.log('已发送编辑消息到服务器:', encryptedEdit);
        // 本地更新消息内容
        const messageElements = document.querySelectorAll(`[data-message-id="${messageId}"]`);
        messageElements.forEach(elem => {
            const textElement = elem.querySelector('.msg-text');
            if (textElement) {
                textElement.textContent = newContent;
            }
        });
    } else {
        alert('聊天服务器尚未连接，请稍后再试。');
    }
}

// smoothScroll函数
function smoothScroll(e) {
    e.preventDefault();
    const targetId = this.getAttribute('href').substring(1);
    const targetElement = document.getElementById(targetId);
    if (targetElement) {
        const targetPosition = targetElement.offsetTop;
        window.scrollTo({
            top: targetPosition - 70,
            behavior: 'smooth'
        });
    }
}
# server.py

import ipaddress
import os
import sys
import asyncio
import base64
import json
import uuid
from datetime import datetime

import websockets
from websockets.exceptions import ConnectionClosedOK, ConnectionClosedError
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QTextEdit, QLineEdit,
    QPushButton, QLabel, QListWidget, QMessageBox, QHBoxLayout
)
from PySide6.QtCore import Qt
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
from qasync import QEventLoop

class ChatServer:
    def __init__(self, gui, host='0.0.0.0', port=20008):
        self.host = host
        self.port = port
        self.gui = gui
        self.clients = {}  # {ip: {"websocket": websocket, "session_key": session_key_bytes}}
        self.blocked_ips = set()
        self.server = None

        # 预共享密钥，需与客户端保持一致（32字节对应256位AES密钥）
        self.PRE_SHARED_KEY = b'G6JrXcZLw1Q8P3F7d9K0M2N4B6V8Y1A3'  # 替换为您的32字节密钥

        # 验证预共享密钥长度
        if len(self.PRE_SHARED_KEY) != 32:
            raise ValueError("预共享密钥长度不正确。应为32字节。")
        else:
            print("预共享密钥长度验证通过。")

    async def handle_client(self, websocket, path):
        user_id = str(uuid.uuid4())
        ip = websocket.remote_address[0]

        # 获取 X-Forwarded-For 请求头中的 IP
        forwarded_for = websocket.request_headers.get('X-Forwarded-For')
        if forwarded_for:
            ip = forwarded_for.split(',')[0].strip()

        if not self.is_valid_ip(ip):
            print(f"无效的IP地址: {ip}")
            await websocket.close()
            return

        if ip in self.blocked_ips:
            await websocket.close()
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: 拒绝来自 {ip} 的连接（已被拉黑）")
            return

        # 等待客户端发送真实 IP 地址
        try:
            client_ip_message = await asyncio.wait_for(websocket.recv(), timeout=30)
            client_ip_data = json.loads(client_ip_message)
            if client_ip_data.get("type") == "client_ip":
                ip = client_ip_data.get("ip", ip)
        except asyncio.TimeoutError:
            print(f"客户端 {ip} 发送IP地址超时")
            await websocket.close()
            return
        except json.JSONDecodeError:
            print(f"客户端 {ip} 发送了无效的JSON数据")
            await websocket.close()
            return

        if not self.is_valid_ip(ip):
            print(f"无效的IP地址: {ip}")
            await websocket.close()
            return

        if ip in self.blocked_ips:
            await websocket.close()
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: 拒绝来自 {ip} 的连接（已被拉黑）")
            return

        # 将客户端信息存储
        self.clients[ip] = {"websocket": websocket, "session_key": None}
        self.gui.add_client(f"{ip}")
        print(f"客户端 {ip} 已连接")

        try:
            # 接收密钥交换请求
            key_exchange_request = await asyncio.wait_for(websocket.recv(), timeout=30)
            key_exchange_data = json.loads(key_exchange_request)
            if key_exchange_data.get('type') != 'request_session_key':
                print(f"未识别的密钥交换请求类型: {key_exchange_data.get('type')}")
                await websocket.close()
                return

            # 生成会话密钥
            session_key_bytes = os.urandom(32)  # 32字节 = 256位
            session_key_b64 = base64.b64encode(session_key_bytes).decode('utf-8')

            # 加密会话密钥
            encrypted_session_key = self.encrypt_message(session_key_b64, self.PRE_SHARED_KEY)

            # 发送会话密钥给客户端
            session_key_message = {
                'type': 'session_key',
                'session_key': encrypted_session_key
            }
            await websocket.send(json.dumps(session_key_message))
            print(f"已发送加密的会话密钥给 {ip}")

            # 存储会话密钥（作为字节）
            self.clients[ip]["session_key"] = session_key_bytes
            print(f"存储的会话密钥为: {self.clients[ip]['session_key']} (type: {type(self.clients[ip]['session_key'])})")

            # 广播系统消息
            await self.broadcast_system_message(
                f"{datetime.now().strftime('%H:%M:%S')} 系统: 欢迎 {ip} 加入聊天")

            # 更新在线用户列表
            await self.update_online_users()

            async for encrypted_message in websocket:
                decrypted_message = self.decrypt_message(encrypted_message, self.clients[ip]["session_key"])
                if not decrypted_message:
                    continue

                await self.handle_message(ip, decrypted_message)

        except (asyncio.TimeoutError, ConnectionClosedOK, ConnectionClosedError):
            print(f"连接超时或断开：{ip}")
        except Exception as e:
            print(f"处理客户端 {ip} 时出错: {e}")
        finally:
            self.remove_client(ip)
            await self.update_online_users()  # 移除用户后更新在线用户列表

    async def update_online_users(self):
        users_list = []
        for ip, client_info in self.clients.items():
            users_list.append(
                {"ip": ip}
            )
        await self.broadcast({
            "type": "update_online_users",
            "users": users_list
        })

    def is_valid_ip(self, ip):
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False

    def encrypt_message(self, message, key):
        # AES-CBC加密
        # message: str (UTF-8)
        # key: bytes (32 bytes)
        if isinstance(message, str):
            message = message.encode('utf-8')
        if isinstance(key, str):
            key = key.encode('utf-8')
        iv = os.urandom(16)  # 128-bit IV
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(message) + padder.finalize()
        ciphertext = encryptor.update(padded_data) + encryptor.finalize()
        # 将IV和密文拼接并进行Base64编码
        iv_ciphertext = iv + ciphertext
        return base64.b64encode(iv_ciphertext).decode('utf-8')

    def decrypt_message(self, encrypted_message, key):
        try:
            # encrypted_message: base64 string
            # key: bytes (32 bytes)
            iv_ciphertext = base64.b64decode(encrypted_message)
            iv = iv_ciphertext[:16]
            ciphertext = iv_ciphertext[16:]
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            unpadder = padding.PKCS7(128).unpadder()
            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
            return plaintext.decode('utf-8')
        except Exception as e:
            print(f"Error decrypting message: {e}")
            return None

    async def handle_message(self, ip, message):
        try:
            message_data = json.loads(message)
        except json.JSONDecodeError:
            print(f"消息解析失败: {message}")
            return

        msg_type = message_data.get('type')

        if msg_type == 'message':
            timestamp = datetime.now().strftime('%H:%M:%S')
            broadcast_data = {
                'type': 'message',
                'id': message_data.get('id'),
                'timestamp': timestamp,
                'username': ip,  # 使用IP作为用户名
                'content': message_data.get('content')
            }
            await self.broadcast(broadcast_data)
            self.gui.display_message(f"{timestamp} {ip}: {message_data.get('content')}")
        elif msg_type == 'image':
            timestamp = datetime.now().strftime('%H:%M:%S')
            broadcast_data = {
                'type': 'image',
                'id': message_data.get('id'),
                'timestamp': timestamp,
                'username': ip,
                'content': message_data.get('content')  # Base64字符串
            }
            await self.broadcast(broadcast_data)
            self.gui.display_message(f"{timestamp} {ip} 发送了一张图片。")
        elif msg_type == 'edit_image':
            # 处理编辑后的图片
            edit_broadcast_data = {
                'type': 'edit_image',
                'id': message_data.get('id'),
                'newContent': message_data.get('newContent')
            }
            await self.broadcast(edit_broadcast_data)
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: {ip} 修改了一张图片。")
        elif msg_type == 'revoke':
            await self.broadcast(message_data)
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: {ip} 撤回了一条消息")
        elif msg_type == 'edit':
            # 处理编辑消息
            edit_broadcast_data = {
                'type': 'edit',
                'id': message_data.get('id'),
                'newContent': message_data.get('newContent')
            }
            await self.broadcast(edit_broadcast_data)
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: {ip} 修改了一条消息")
        else:
            print(f"未知的消息类型: {msg_type}")

    def remove_client(self, ip):
        client_info = self.clients.pop(ip, None)
        if client_info:
            websocket = client_info["websocket"]
            self.gui.remove_client(ip)
            print(f"客户端 {ip} 已断开")

    async def broadcast(self, data):
        message = json.dumps(data)
        for ip, client_info in self.clients.items():
            websocket = client_info["websocket"]
            session_key = client_info["session_key"]  # bytes
            if not session_key:
                continue
            encrypted_message = self.encrypt_message(message, session_key)
            try:
                await websocket.send(encrypted_message)
            except Exception as e:
                print(f"Error sending message to client {ip}: {e}")

    async def broadcast_system_message(self, message):
        broadcast_data = {
            'type': 'system',
            'timestamp': datetime.now().strftime('%H:%M:%S'),
            'content': message
        }
        await self.broadcast(broadcast_data)
        self.gui.display_message(message)

    async def start_server(self):
        self.server = await websockets.serve(self.handle_client, self.host, self.port)
        self.gui.update_status(f"服务器运行中: {self.host}:{self.port} (WS)")
        print(f"服务器运行中: {self.host}:{self.port} (WS)")
        await self.server.wait_closed()

    def stop_server(self):
        if self.server:
            self.server.close()
            self.gui.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: 服务器已关闭")
            print(f"{datetime.now().strftime('%H:%M:%S')} 系统: 服务器已关闭")

class ServerGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Websocket 内网穿透 TCP 中转")
        self.setGeometry(100, 100, 800, 600)
        self.setup_ui()
        self.server = ChatServer(self, port=20008)  # 设置为20008端口

    def setup_ui(self):
        self.layout = QVBoxLayout(self)

        self.status_label = QLabel("服务器未启动")
        self.layout.addWidget(self.status_label)

        self.chat_display = QTextEdit()
        self.chat_display.setReadOnly(True)
        self.layout.addWidget(self.chat_display)

        self.client_list = QListWidget()
        self.layout.addWidget(QLabel("当前连接的客户端 IP"))
        self.layout.addWidget(self.client_list)

        self.setup_controls()

    def setup_controls(self):
        # 发送服务器消息
        message_layout = QHBoxLayout()
        self.message_input = QLineEdit()
        self.message_input.setPlaceholderText("输入服务器消息")
        message_layout.addWidget(self.message_input)
        send_button = QPushButton("发送")
        send_button.clicked.connect(self.send_message)
        send_button.setStyleSheet("margin-left: 10px;")
        message_layout.addWidget(send_button)
        self.layout.addLayout(message_layout)

        # 拉黑/解除拉黑 IP
        block_layout = QHBoxLayout()
        self.block_input = QLineEdit()
        self.block_input.setPlaceholderText("输入要拉黑/解除拉黑的IP")
        block_layout.addWidget(self.block_input)
        block_button = QPushButton("拉黑IP")
        block_button.clicked.connect(self.block_ip)
        block_layout.addWidget(block_button)
        unblock_button = QPushButton("解除拉黑IP")
        unblock_button.clicked.connect(self.unblock_ip)
        block_layout.addWidget(unblock_button)
        self.layout.addLayout(block_layout)

        # 关闭服务器按钮
        shutdown_button = QPushButton("关闭服务器")
        shutdown_button.clicked.connect(self.shutdown_server)
        self.layout.addWidget(shutdown_button)

        # 双击客户端 IP 拉黑
        self.client_list.itemDoubleClicked.connect(self.on_client_double_clicked)

    def on_client_double_clicked(self, item):
        self.block_input.setText(item.text())  # 直接使用IP

    def display_message(self, message):
        self.chat_display.append(message)

    def add_client(self, client_ip):
        if not self.client_list.findItems(client_ip, Qt.MatchExactly):
            self.client_list.addItem(client_ip)

    def remove_client(self, client_ip):
        for item in self.client_list.findItems(client_ip, Qt.MatchExactly):
            self.client_list.takeItem(self.client_list.row(item))

    def update_status(self, status):
        self.status_label.setText(status)

    def send_message(self):
        message = self.message_input.text().strip()
        if message:
            asyncio.create_task(self.server.broadcast({
                'type': 'message',
                'id': 'server_' + str(int(datetime.now().timestamp())),
                'timestamp': datetime.now().strftime('%H:%M:%S'),
                'username': '系统',
                'content': message
            }))
            self.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: {message}")
            self.message_input.clear()

    def block_ip(self):
        ip = self.block_input.text().strip()
        if ip:
            if self.server.is_valid_ip(ip):
                self.server.blocked_ips.add(ip)
                self.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: 已拉黑IP {ip}")
                self.block_input.clear()
            else:
                QMessageBox.warning(self, '错误', '请输入有效的IP地址。')

    def unblock_ip(self):
        ip = self.block_input.text().strip()
        if ip and ip in self.server.blocked_ips:
            self.server.blocked_ips.remove(ip)
            self.display_message(f"{datetime.now().strftime('%H:%M:%S')} 系统: 已解除拉黑IP {ip}")
            self.block_input.clear()
        elif ip:
            QMessageBox.information(self, '信息', f"IP {ip} 未被拉黑。")

    def shutdown_server(self):
        if QMessageBox.question(self, '关闭服务器', '确定要关闭服务器吗?', QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            self.server.stop_server()
            QApplication.quit()

def main():
    app = QApplication(sys.argv)
    loop = QEventLoop(app)
    asyncio.set_event_loop(loop)
    gui = ServerGUI()
    gui.show()
    asyncio.ensure_future(gui.server.start_server())
    with loop:
        loop.run_forever()

if __name__ == "__main__":
    main()
